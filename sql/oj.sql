DROP TABLE IF EXISTS `daily_question`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `daily_question` (
                                  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '记录 id',
                                  `question_id` bigint NOT NULL COMMENT '随机选中的题目 id',
                                  `date` date NOT NULL COMMENT '题目对应的日期',
                                  `question_img` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
                                  PRIMARY KEY (`id`),
                                  UNIQUE KEY `idx_date` (`date`)
) ENGINE=InnoDB AUTO_INCREMENT=1910198094486654979 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='每日题目记录';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `daily_question`
--

LOCK TABLES `daily_question` WRITE;
/*!40000 ALTER TABLE `daily_question` DISABLE KEYS */;
INSERT INTO `daily_question` VALUES (1845070935393099777,1844652758788026369,'2024-10-12','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/bfc53bc9-e531-4830-9940-d7ad49ef835a.png'),(1845365739695939585,1844652329786224641,'2024-10-13','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/a3e4bf04-581d-4615-b3ca-f690ab88c8ebwordCloud-6984284909.png'),(1851480089963909122,1845093212373405698,'2024-10-30','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/8cd2b485-6cda-4fc8-a125-c83835386aa6wordCloud-2082013189.png'),(1851833923009630209,1844652329786224641,'2024-10-31','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/710ad7cb-8254-4d10-8760-05d5f03489f4wordCloud-9131618137.png'),(1852300016962576386,1845094162697834497,'2024-11-01','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/b77339a6-6b52-40fb-9fb4-df04959c859dwordCloud-2412190816.png'),(1852580320214298625,1845093820048363522,'2024-11-02','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/a6aa74b0-ecc7-44df-b18a-fddb3c3f85b1wordCloud-9891648836.png'),(1852833923009630209,1844652329786224641,'2024-11-23','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/710ad7cb-8254-4d10-8760-05d5f03489f4wordCloud-9131618137.png'),(1852924525654585345,1845094162697834497,'2024-11-03','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/5a003c5b-a074-4bb5-bef1-10939ccbb0bawordCloud3-5656690182.png'),(1853292509967519745,1845094452876562433,'2024-11-04','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/8cd2b485-6cda-4fc8-a125-c83835386aa6wordCloud-2082013189.png'),(1853666310190387201,1845094883665137666,'2024-11-05','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/85246f9e-067a-4571-9bfa-a70917f4a4d3wordCloud-8215277964.png'),(1854151252829646848,1845118281699053569,'2024-11-22','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/c0ca9d55-04a9-4014-b8d8-1a0174ffe46ewordCloud-1415979003.png'),(1854151252829646849,1845118281699053569,'2024-11-06','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/dc8be35b-8f30-4f9a-9d89-dc05f035f3a1wordCloud-0886025949.png'),(1859052681977401346,1845118475895328770,'2024-11-20','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/c0ca9d55-04a9-4014-b8d8-1a0174ffe46ewordCloud-1415979003.png'),(1859420893902618625,1845094883665137666,'2024-11-21','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/1087918a-7e1c-45bb-91e8-6192c29b0fd8wordCloud-5456625250.png'),(1859420893902618626,1845094883665137666,'2024-11-24','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/c0ca9d55-04a9-4014-b8d8-1a0174ffe46ewordCloud-1415979003.png'),(1859420893902618627,1845094883665137666,'2024-12-02','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/c0ca9d55-04a9-4014-b8d8-1a0174ffe46ewordCloud-1415979003.png'),(1859420893902618630,1845094883665137666,'2024-12-29','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/c0ca9d55-04a9-4014-b8d8-1a0174ffe46ewordCloud-1415979003.png'),(1859420893902618631,1845094883665137666,'2025-01-04','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/c0ca9d55-04a9-4014-b8d8-1a0174ffe46ewordCloud-1415979003.png'),(1909989379523223553,1844216221361299458,'2025-04-08','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/c0ca9d55-04a9-4014-b8d8-1a0174ffe46ewordCloud-1415979003.png'),(1909990170954858497,1844216221361299458,'2025-04-09','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/c0ca9d55-04a9-4014-b8d8-1a0174ffe46ewordCloud-1415979003.png'),(1910198094486654978,1844216221361299458,'2025-04-10','https://cetide-1325039295.cos.ap-chengdu.myqcloud.com/c0ca9d55-04a9-4014-b8d8-1a0174ffe46ewordCloud-1415979003.png');
/*!40000 ALTER TABLE `daily_question` ENABLE KEYS */;
UNLOCK TABLES;



--
-- Table structure for table `question`
--

DROP TABLE IF EXISTS `question`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `question` (
                            `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
                            `title` varchar(512) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '标题',
                            `content` text COLLATE utf8mb4_unicode_ci COMMENT '内容',
                            `tags` varchar(1024) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '标签列表（json 数组）',
                            `answer` text COLLATE utf8mb4_unicode_ci COMMENT '题目答案',
                            `submitNum` int NOT NULL DEFAULT '0' COMMENT '题目提交数',
                            `acceptedNum` int NOT NULL DEFAULT '0' COMMENT '题目通过数',
                            `judgeCase` text COLLATE utf8mb4_unicode_ci COMMENT '判题用例（json 数组）',
                            `judgeConfig` text COLLATE utf8mb4_unicode_ci COMMENT '判题配置（json 对象）',
                            `thumbNum` int NOT NULL DEFAULT '0' COMMENT '点赞数',
                            `favourNum` int NOT NULL DEFAULT '0' COMMENT '收藏数',
                            `userId` bigint NOT NULL COMMENT '创建用户 id',
                            `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
                            `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
                            `isDelete` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除',
                            PRIMARY KEY (`id`),
                            KEY `idx_userId` (`userId`)
) ENGINE=InnoDB AUTO_INCREMENT=1873366754214879234 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='题目';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `question`
--

LOCK TABLES `question` WRITE;
/*!40000 ALTER TABLE `question` DISABLE KEYS */;
INSERT INTO `question` VALUES (1844216221361299458,'最大子列和问题','给定K个整数组成的序列{ N \n1\n​\n , N \n2\n​\n , ..., N \nK\n​\n  }，“连续子列”被定义为{ N \ni\n​\n , N \ni+1\n​\n , ..., N \nj\n​\n  }，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 \n\n本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：\n\n数据1：与样例等价，测试基本正确性；\n数据2：102个随机整数；\n数据3：103个随机整数；\n数据4：104个随机整数；\n数据5：105个随机整数；\n\n输入格式:\n\n输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。 \n\n输出格式:\n\n在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 \n\n输入样例:\n\n6\n\n-2 11 -4 13 -5 -2\n\n输出样例:\n\n20','[]','import java.util.Scanner;\n\npublic class MaxSubarraySum {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 读取整数 K\n        int K = scanner.nextInt();\n        scanner.nextLine(); // 读取换行符\n\n        // 读取 K 个整数\n        String[] numbersStr = scanner.nextLine().split(\" \");\n        int[] numbers = new int[K];\n        for (int i = 0; i < K; i++) {\n            numbers[i] = Integer.parseInt(numbersStr[i]);\n        }\n\n        // 计算最大子列和\n        int maxSum = findMaxSubarraySum(numbers);\n\n        // 输出结果\n        System.out.println(maxSum);\n    }\n\n    /**\n     * 使用 Kadane 算法找到最大子列和\n     *\n     * @param nums 给定的整数序列\n     * @return 最大子列和\n     */\n    private static int findMaxSubarraySum(int[] nums) {\n        int maxSoFar = 0;\n        int maxEndingHere = 0;\n\n        for (int num : nums) {\n            maxEndingHere += num;\n            if (maxEndingHere < 0) {\n                maxEndingHere = 0;\n            }\n            if (maxEndingHere > maxSoFar) {\n                maxSoFar = maxEndingHere;\n            }\n        }\n\n        return maxSoFar;\n    }\n}\n',50,27,'[{\"input\":\"6 -2 11 -4 13 -5 -2\",\"output\":\"20\"}]','{\"timeLimit\":9993,\"memoryLimit\":6400,\"stackLimit\":8192}',44,50,1,'2024-10-10 11:19:45','2024-12-29 21:55:13',0),(1844652329786224641,'h0142. 俄罗斯方块','以下是一个俄罗斯方块玩发，加入新机制，翻倍消除器，其特性如下：\n\n初始有n列非空砖块，消除器内的计数器为K = 0，高度依次为h1，h2，... hn，有效操作次数为t = 0\n\n  1.消除器可以多次使用，每次可以选择任意个hi> = 2^k-的砖块列，使其高度减少2^k\n\n  2.每次使用后，无论选择多少列（包括0），计数器增加1，K = K + 1\n\n  3.若选取的个数cntj> = 1则记为一次有效操作次数，t = t + 1\n\n  4.若不再存在hi> = 2^k-，结束\n\n如果每次使用翻倍消除器的时候，都用最少的有效操作次数，将所有列的砖块数量之和尽可能的减少了\n现在，对于某一个局面Q，请你编个程序实现究竟进行了几次有效操作？\n\n输入格式:\n第一行为正整数M表示使用的测试组数M <= 10\n接下来M组游戏局面：\n\n每组第一行输入一个正整数N表示含有砖块的列的数量N <= 100000\n\n接下来一行为N个正整数hi表示第i 个非零列的高度 hi <= 2^20 \n\n\n输出格式:\n\n输出M行\n\n每行一个整数,表示启动消除器后的有效操作次数\n\n输入样例:\n\n2\n\n2 \n\n5 1\n\n3\n\n1 2 3 \n\n输出样例:\n\n2\n\n2','[]','import java.util.Scanner;\n\npublic class TetrisEliminator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int M = scanner.nextInt(); // 测试组数\n        \n        for (int m = 0; m < M; m++) {\n            int N = scanner.nextInt(); // 列数\n            int[] heights = new int[N];\n            \n            // 读取每列的高度\n            for (int i = 0; i < N; i++) {\n                heights[i] = scanner.nextInt();\n            }\n            \n            // 计算有效操作次数\n            int operations = calculateOperations(heights);\n            System.out.println(operations);\n        }\n        \n        scanner.close();\n    }\n\n    private static int calculateOperations(int[] heights) {\n        int operations = 0;\n        int k = 0;\n        \n        while (true) {\n            boolean found = false;\n            for (int i = 0; i < heights.length; i++) {\n                if (heights[i] >= (1 << k)) {\n                    found = true;\n                    heights[i] -= (1 << k);\n                }\n            }\n            \n            if (!found) break;\n            k++;\n            if (found) operations++;\n        }\n        \n        return operations;\n    }\n}\n',0,0,'[{\"input\":\"2 2  5 1 3 1 2 3 \",\"output\":\"2 2\"}]','{\"timeLimit\":1000,\"memoryLimit\":6400,\"stackLimit\":8179}',0,0,1844544596890112001,'2024-10-11 16:12:42','2024-10-11 16:12:42',0),(1844652758788026369,'h0143. 铺砖问题','现用若干砖去铺满一条长度为N的路，不允许重叠和超出，问有多少种不同的铺法\n已知砖的长度为奇数，如1,3,5,7,9......\n\n输入格式:\n第一行为一个整数T（1<=T<=30）\n接下来T行，每行一个整数N（0<=n<=1000）\n\n输出格式:\n对于每个测试样例，输出对应的答案\n由于答案可能很大，结果对1e9+7取模\n\n\n\n输入样例:\n\n2\n\n2\n\n5\n\n输出样例:\n\n1\n\n5','[]','import java.util.Scanner;\n\npublic class BrickPaving {\n    private static final long MOD = 1_000_000_007L;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt(); // 测试组数\n\n        for (int t = 0; t < T; t++) {\n            int N = scanner.nextInt(); // 路的长度\n            long[] dp = new long[N + 1];\n\n            // 初始化dp数组\n            dp[0] = 1;\n\n            // 动态规划计算dp数组\n            for (int i = 1; i <= N; i++) {\n                for (int j = 1; j <= i; j += 2) { // 只考虑奇数长度的砖\n                    dp[i] = (dp[i] + dp[i - j]) % MOD;\n                }\n            }\n\n            System.out.println(dp[N]);\n        }\n\n        scanner.close();\n    }\n}\n',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":1000,\"memoryLimit\":1000,\"stackLimit\":8192}',0,0,1844544596890112001,'2024-10-11 16:14:24','2024-10-11 16:14:24',0),(1845093212373405698,'h0013.放置卡片','你能把一叠卡片挂在桌子上多远?如果您有一张卡片，您可以创建半张卡片长度的最大悬垂。(我们假设纸牌必须垂直于桌子)用两张牌，你可以使上面的牌悬在下面一半的牌长，和下面的一张牌悬在桌子上三分之一的牌长，总的最大悬在1/2 + 1/3 = 5/6张牌长。一般来说，你可以让n张牌悬空1/2 + 1/3 + 1/4 +…+ 1/(n + 1)张牌的长度，上牌悬于上表1/2处，下一张悬于上表1/(n + 1)处，下一张悬于上表1/(n + 1)处，下一张悬于上表1/(n + 1)处，下一张悬于上表1/(n + 1)处，如下图所示。\n\n1056-1.gif\n\n输入格式:\n输入由一个或多个测试用例组成，后面是一行包含数字0.00的代码，表示输入的结束。每个测试用例都是一行，其中包含一个正的浮点数c，其值至少为0.01，最多为8.88;c正好包含三位数字。\n\n输出格式:\n对于每个测试用例，输出实现至少c卡长度的悬垂所需的卡的最小数量。使用示例中所示的准确输出格式。\n\n输入样例:\n在这里给出一组输入。例如：\n\n8.80\n\n1.00\n\n3.71\n\n0.04\n\n6.88\n\n0.00\n\n输出样例:\n\n10124 card(s)\n\n3 card(s)\n\n61 card(s)\n\n1 card(s)\n\n\n1483 card(s)\n','[]','import java.util.Scanner;\n\npublic class CardSuspendedProblem {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (true) {\n            double c = scanner.nextDouble();\n            if (c == 0.00) {\n                break;\n            }\n            int cardsNeeded = findMinimumCards(c);\n            System.out.printf(\"%d card(s)%n\", cardsNeeded);\n        }\n\n        scanner.close();\n    }\n\n    private static int findMinimumCards(double c) {\n        int n = 1;\n        double sum = 0.0;\n\n        while (sum < c) {\n            sum += 1.0 / (n + 1);\n            n++;\n        }\n\n        return n;\n    }\n}\n',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":4000,\"memoryLimit\":64000,\"stackLimit\":8192}',0,0,1844659788059840513,'2024-10-12 21:24:36','2024-10-12 21:24:36',0),(1845093578993324033,'h0216.基站','5G是目前4G标准之外的下一代电信标准。5G规划的目标是比目前的4G容量更大，允许更高密度的移动宽带用户，并支持设备对可靠信息和大规模的无线通信。一家电信公司想要安装更多的基站，为客户提供更好的通信。由于安装成本和可用位置的原因，公司只能在L(2≤L≤10万)个候选位置安装S(2≤S≤L)个基站。由于基站工作在同一频段，它们会产生干扰并导致严重的性能下降。为了给客户提供高质量的通信体验，公司希望尽可能地扩大基站之间的距离，以减少基站之间的无线干扰。假设L候选位置在P1、P2、···、PL位置上呈直线(0≤Pi≤1,000,000)，公司希望在L候选位置上安装基站。S个基站之间最大的最小距离是多少?\n\n输入格式:\n输入数据包括多个测试集。每个集合以一行开始，其中指定L(即候选位置的数量)和S(即基站的数量)。下一行包含L个用空格分隔的整数，分别表示P1、P2、···、PL，输入数据以“0 0”结尾。\n\n输出格式:\n对于每一组，您需要输出一行，这一行应该是基站之间的最大最小距离。\n\n输入样例:\n\n5 3\n\n2 3 9 6 11\n\n4 3\n\n\n1 4 9 10\n\n0 0\n\n输出样例:\n\n4\n\n3\n','[]','import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class BaseStationProblem {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (true) {\n            int L = scanner.nextInt();\n            int S = scanner.nextInt();\n\n            if (L == 0 && S == 0) {\n                break;\n            }\n\n            int[] positions = new int[L];\n            for (int i = 0; i < L; i++) {\n                positions[i] = scanner.nextInt();\n            }\n\n            Arrays.sort(positions);\n            int result = findMaxMinDistance(positions, S);\n            System.out.println(result);\n        }\n\n        scanner.close();\n    }\n\n    private static int findMaxMinDistance(int[] positions, int S) {\n        int left = 1;\n        int right = positions[positions.length - 1] - positions[0];\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (canPlaceStations(positions, S, mid)) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n\n        return left - 1;\n    }\n\n    private static boolean canPlaceStations(int[] positions, int S, int distance) {\n        int count = 1;\n        int lastPosition = positions[0];\n\n        for (int i = 1; i < positions.length; i++) {\n            if (positions[i] - lastPosition >= distance) {\n                count++;\n                lastPosition = positions[i];\n            }\n\n            if (count == S) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":400,\"memoryLimit\":6400,\"stackLimit\":8192}',0,0,1844659788059840513,'2024-10-12 21:26:04','2024-10-12 21:26:04',0),(1845093820048363522,'h0149. 计算','给出 ，求∑(i=1,n)∑(j=1,n)i×j和∏(i=1,n)∏(j=1,n) i×j答案对998244353取模。\n\n输入格式:\n多组数据。\n第一行一个数t(1<=t<=10)，表示测试数据组数。\n接下来 t行，每行一个数n(1<=n<=10000000) 。\n\n输出格式:\n对于每一组测试数据，输出一行两个数，即这组测试数据的答案。\n\n\n输入样例:\n\n1\n\n1\n\n输出样例:\n\n1 1','[]','import java.util.Scanner;\n\npublic class SumOfProducts {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int t = scanner.nextInt(); // 测试数据组数\n        long mod = 998244353L;\n\n        for (int i = 0; i < t; i++) {\n            int n = scanner.nextInt();\n            long result = calculateSum(n, mod);\n            System.out.println(result + \" \" + result);\n        }\n\n        scanner.close();\n    }\n\n    private static long calculateSum(int n, long mod) {\n        long sum = (long) n * (n + 1) / 2;\n        return (sum * sum) % mod;\n    }\n}\n',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":400,\"memoryLimit\":6400,\"stackLimit\":8192}',0,0,1844659788059840513,'2024-10-12 21:27:01','2024-10-12 21:27:01',0),(1845094162697834497,'h0153. 挑剔程度','小云喜欢网购，她经常购买的网店有N家，每一家都记录了她退货的次数，为了减少自己的挑剔程度（所有的店里面最大的退货次数），她可以选择其中的K家，将这些店的数据清空。 请问她能最后获得的最小的挑剔程度是多少？\n\n输入格式:\n第一行有两个正整数N，K。意义与题面中的相同。\n\n第二行有N个整数ai，代表第i家店的退货的次数。\n\n数据保证N,K≤20000,0≤ai<1 000 000 000\n\n输出格式:\n\n输出1行，代表最后获得的最小的挑剔程度。\n\n\n输入样例1:\n\n3 1\n\n1 3 2\n\n输出样例1:\n\n2\n\n输入样例2:\n\n8 7\n\n1 5 6 3 4 5 6 0\n\n输出样例2:\n\n0\n','[二分]','import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class MinPickyDegree {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n\n        int[]退货次数 = new int[N];\n        for (int i = 0; i < N; i++) {\n            退货次数[i] = scanner.nextInt();\n        }\n\n        scanner.close();\n\n        int minPickyDegree = findMinPickyDegree(退货次数, K);\n        System.out.println(minPickyDegree);\n    }\n\n    private static int findMinPickyDegree(int[]退货次数, int K) {\n        Arrays.sort(退货次数);\n\n        int maxReturnCount = 0;\n        for (int i = 退货次数.length - 1; i >= 退货次数.length - K; i--) {\n            maxReturnCount = Math.max(maxReturnCount, 退货次数[i]);\n        }\n\n        return maxReturnCount;\n    }\n}\n',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":400,\"memoryLimit\":6400,\"stackLimit\":8192}',0,0,1844659788059840513,'2024-10-12 21:28:23','2024-11-03 15:23:37',0),(1845094452876562433,'h0152. 故事计算题','小米给小宝讲了一个小故事。从前有座山，山上有N个庙，每个庙里有1个老和尚和N+1个小和尚。山中流传着一个故事：从前有座山，山上有N+1个庙，每个庙里有1个老和尚和N+2个小和尚。山中流传着一个故事：从前有座..........从前有座山，山上有M个庙，每个庙里有1个老和尚和M+1个小和尚。小宝听完这个故事后想知道一共有多少个小和尚？\n\n\n输入格式:\n第一行有一个正整数K。\n\n接下来有K行，每行有两个数N，M。\n\n\n数据保证1≤K≤100 000,0≤N，M<1 000 000。\n\n\n输出格式:\n\n输出K行，表示结果\n\n\n输入样例:\n\n2\n\n1 3\n\n2 4\n\n输出样例:\n\n20\n\n38','[]','import java.util.Scanner;\n\npublic class TempleMonksProblem {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int K = scanner.nextInt();\n\n        for (int i = 0; i < K; i++) {\n            int N = scanner.nextInt();\n            int M = scanner.nextInt();\n            long totalMonks = calculateTotalMonks(N, M);\n            System.out.println(totalMonks);\n        }\n\n        scanner.close();\n    }\n\n    private static long calculateTotalMonks(int N, int M) {\n        return (long) M * (N + 1);\n    }\n}\n',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":400,\"memoryLimit\":64000,\"stackLimit\":8192}',0,0,1844659788059840513,'2024-10-12 21:29:32','2024-10-12 21:29:32',0),(1845094662285578242,'h0004.双倍','给出2到15个不同的正整数，计算在这些数里面有多少对数满足一个数是另一个数的两倍。比如给出\n   1    4    3    2    9    7    18    22\n答案是3，因为2是1的两倍，4是2的两倍，18是9的两倍。\n\n输入格式:\n输入包括多个测试用例。每个测试用例一行，给出2到15个两两不同且小于100的正整数。每一行最后一个数是0，表示这一行的结束，这个数不属于那2到15个给定的正整数。输入的最后一行仅给出整数-1，这行表示测试用例的输入结束，不用进行处理。\n\n输出格式:\n\n对每个测试用例，输出一行，给出有多少对数满足其中一个数是另一个数的两倍。\n\n\n\n输入样例:\n\n1 4 3 2 9 7 18 22 0\n\n2 4 8 10 0\n\n7 5 11 13 1 3 0\n\n-1\n\n输出样例:\n\n3\n\n2\n\n0','[]','import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class DoublePairsProblem {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (scanner.hasNextInt()) {\n            int number = scanner.nextInt();\n            if (number == -1) {\n                break;\n            }\n\n            HashSet<Integer> numbers = new HashSet<>();\n            while (number != 0) {\n                numbers.add(number);\n                number = scanner.nextInt();\n            }\n\n            int count = countDoublePairs(numbers);\n            System.out.println(count);\n        }\n\n        scanner.close();\n    }\n\n    private static int countDoublePairs(HashSet<Integer> numbers) {\n        int count = 0;\n\n        for (int num : numbers) {\n            if (num > 0 && num * 2 < 100 && numbers.contains(num * 2)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n}\n',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":400,\"memoryLimit\":6400,\"stackLimit\":8192}',0,0,1844659788059840513,'2024-10-12 21:30:22','2024-10-12 21:30:22',0),(1845094883665137666,'h0044. 连续素数的和','一些正整数能够表示为一个或多个连续素数的和。给出一个正整数，有多少个这样的表示？例如，整数53有两个表示：5+7+11+13+17和53；整数41有三个表示：2+3+5+7+11+13，11+13+17和41；整数3只有一个表示：3；整数20没有这样的表示。注意加法操作数必须是连续的素数，因此，对于整数20，7+13 和 3+5+5+7 都不是有效的表示。\n请写一个程序，对于一个给出的正整数，程序给出连续素数的和的表示数。\n\n\n输入格式:\n\n输入一个正整数序列，每个数一行，在2到10000之间取值。输入结束以0表示。\n\n\n输出格式:\n\n输出的每一行对应输入的每一行，除了最后的0。输出的每一行对于一个输入的正整数，给出连续素数的和的表示数。输出中没有其他的字符。\n\n\n输入样例:\n\n2\n\n3\n\n17\n\n41\n\n20\n\n666\n\n12\n\n\n53\n\n0\n\n输出样例:\n\n在这里给出相应的输出。例如：\n\n\n\n1\n\n1\n\n2\n\n\n3\n\n0\n\n0\n\n1\n\n2','[]','import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class PrimeSumProblem {\n\n    public static void main(String[] args) {\n        List<Integer> primes = generatePrimes(10000);\n        Scanner scanner = new Scanner(System.in);\n\n        while (scanner.hasNextInt()) {\n            int number = scanner.nextInt();\n            if (number == 0) {\n                break;\n            }\n\n            int count = countPrimeSums(primes, number);\n            System.out.println(count);\n        }\n\n        scanner.close();\n    }\n\n    private static List<Integer> generatePrimes(int limit) {\n        boolean[] isPrime = new boolean[limit + 1];\n        for (int i = 2; i <= limit; i++) {\n            isPrime[i] = true;\n        }\n\n        for (int p = 2; p * p <= limit; p++) {\n            if (isPrime[p]) {\n                for (int multiple = p * p; multiple <= limit; multiple += p) {\n                    isPrime[multiple] = false;\n                }\n            }\n        }\n\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i <= limit; i++) {\n            if (isPrime[i]) {\n                primes.add(i);\n            }\n        }\n\n        return primes;\n    }\n\n    private static int countPrimeSums(List<Integer> primes, int target) {\n        int count = 0;\n        for (int start = 0; start < primes.size(); start++) {\n            int sum = 0;\n            for (int end = start; end < primes.size(); end++) {\n                sum += primes.get(end);\n                if (sum == target) {\n                    count++;\n                    break;\n                } else if (sum > target) {\n                    break;\n                }\n            }\n        }\n\n        return count;\n    }\n}\n',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":400,\"memoryLimit\":6400,\"stackLimit\":8192}',0,0,1844659788059840513,'2024-10-12 21:31:15','2024-10-12 21:31:15',0),(1845118184223428610,'h0044. 连续素数的和','一些正整数能够表示为一个或多个连续素数的和。给出一个正整数，有多少个这样的表示？例如，整数53有两个表示：5+7+11+13+17和53；整数41有三个表示：2+3+5+7+11+13，11+13+17和41；整数3只有一个表示：3；整数20没有这样的表示。注意加法操作数必须是连续的素数，因此，对于整数20，7+13 和 3+5+5+7 都不是有效的表示。\n请写一个程序，对于一个给出的正整数，程序给出连续素数的和的表示数。\n\n输入格式:\n输入一个正整数序列，每个数一行，在2到10000之间取值。输入结束以0表示。\n\n输出格式:\n输出的每一行对应输入的每一行，除了最后的0。输出的每一行对于一个输入的正整数，给出连续素数的和的表示数。输出中没有其他的字符。\n\n输入样例:\n2\n3\n17\n41\n20\n666\n12\n53\n0\n输出样例:\n在这里给出相应的输出。例如：\n\n1\n1\n2\n3\n0\n0\n1\n2','[]','',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":400,\"memoryLimit\":6400,\"stackLimit\":8192}',0,0,1844659788059840513,'2024-10-12 23:03:50','2024-10-12 23:03:50',0),(1845118281699053569,'h0139. Humidex','Adapted from Wikipedia, the free encyclopedia\nThe humidex is a measurement used by Canadian meteorologists to reflect the combined effect of heat and humidity. It differs from the heat index used in the United States in using dew point rather than relative humidity.\nWhen the temperature is 30 C (86 F) and the dew point is 15 C (59 F), the humidex is 34 (note that humidex is a dimensionless number, but that the number indicates an approximate temperature in C). If the temperature remains 30 C and the dew point rises to 25 C (77 F), the humidex rises to 42.3. \n\nThe humidex tends to be higher than the U.S. heat index at equal temperature and relative humidity. \n\nThe current formula for determining the humidex was developed by J.M. Masterton and F.A. Richardson of Canada\'s Atmospheric Environment Service in 1979.\nAccording to the Meteorological Service of Canada, a humidex of at least 40 causes \"great discomfort\" and above 45 is \"dangerous.\" When the humidex hits 54, heat stroke is imminent. \n\nThe record humidex in Canada occurred on June 20, 1953, when Windsor, Ontario hit 52.1. (The residents of Windsor would not have known this at the time, since the humidex had yet to be invented.) More recently, the humidex reached 50 on July 14, 1995 in both Windsor and Toronto. \n\nThe humidex formula is as follows: \n\nhumidex = temperature + h\nh = (0.5555)*(e - 10.0)\ne = 6.11 * exp [5417.7530 * ((1/273.16) - (1/(dewpoint+273.16)))]\nwhere exp(x) is 2.718281828 raised to the exponent x.\nWhile humidex is just a number, radio announcers often announce it as if it were the temperature, e.g. \"It\'s 47 degrees out there ... [pause] .. with the humidex,\". \n\nSometimes weather reports give the temperature and dewpoint, or the temperature and humidex, but rarely do they report all three measurements. Write a program that, given any two of the measurements, will calculate the third.\nYou may assume that for all inputs, the temperature, \n\ndewpoint, and humidex are all between -100 C and 100 C.\n\n输入格式:\nInput will consist of a number of lines. Each line except the last will consist of four items separated by spaces: a letter, a number, a second letter, and a second number. \n\nEach letter specifies the meaning of the number that follows it, and will be either T, indicating temperature, D, indicating dewpoint, or H, indicating humidex. The last line of input will consist of the single letter E.\n\n输出格式:\nFor each line of input except the last, produce one line of output. Each line of output should have the form: \n\nT number D number H number\nwhere the three numbers are replaced with the temperature, dewpoint, and humidex. \n\nEach value should be expressed rounded to the nearest tenth of a degree, with exactly one digit after the decimal point. All temperatures are in degrees celsius. \n\n输入样例:\nT 30 D 15\nT 30.0 D 25.0\nE\n输出样例:\nT 30.0 D 15.0 H 34.0\nT 30.0 D 25.0 H 42.3','[]','',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":400,\"memoryLimit\":6400,\"stackLimit\":8192}',0,0,1844659788059840513,'2024-10-12 23:04:13','2024-10-12 23:04:13',0),(1845118475895328770,'h0045. 限速','B和T踏上行程，但他们汽车的里程表坏了，因此他们不知道他们驾车走了多少英里。幸运的是，B有一个正在运行的跑表，可以记录他们的速度和驾驶了多少时间。然而，这个跑表的记录方式有些古怪，他们需要计算总的驾驶距离。请您编写一个程序完成这项计算。\n\n图片11.png\n\n输入格式:\n输入由一个或多个测试用例组成。每个测试用例开始的第一行为一个整数n，1≤n≤10；后面是n对值，每对一行。每对的第一个值s是时速，第二个值t是总的耗费时间。s和t都是整数，1 ≤s≤90并且1≤t≤12。t的值总是增序。n的值取-1表示输入结束。\n\n输出格式:\n对于每一个测试用例，输出行驶距离，然后空格，输出单词\"miles\"。\n\n输入样例:\n3\n20 2\n30 6\n10 7\n2\n60 1\n30 5\n4\n15 1\n25 2\n30 3\n10 5\n−1\n输出样例:\n170 miles\n180 miles\n90 miles','[]','',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":400,\"memoryLimit\":6400,\"stackLimit\":8192}',0,0,1844659788059840513,'2024-10-12 23:04:59','2024-10-12 23:04:59',0),(1845118562763558914,'h0005.连续质数的和','一些正整数能够表示为一个或多个连续素数的和。给出一个正整数，有多少个这样的表示？例如，整数53有两个表示：5+7+11+13+17和53；整数41有三个表示：2+3+5+7+11+13，11+13+17和41；整数3只有一个表示：3；整数20没有这样的表示。注意加法操作数必须是连续的素数，因此，对于整数20，7+13 和 3+5+5+7 都不是有效的表示。\n请写一个程序，对于一个给出的正整数，程序给出连续素数的和的表示数。\n\n输入格式:\n输入一个正整数序列，每个数一行，在2到10000之间取值。输入结束以0表示。\n\n输出格式:\n输出的每一行对应输入的每一行，除了最后的0。输出的每一行对于一个输入的正整数，给出连续素数的和的表示数。输出中没有其他的字符。\n\n输入样例:\n2\n3\n17\n41\n20\n666\n12\n53\n8819\n8929\n9719\n0\n输出样例:\n1\n1\n2\n3\n0\n0\n1\n2\n4\n1\n1','[]','',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":400,\"memoryLimit\":6400,\"stackLimit\":8192}',0,0,1844659788059840513,'2024-10-12 23:05:20','2024-10-12 23:05:20',0),(1873366754214879233,'一道题','public','[]','public',0,0,'[{\"input\":\"\",\"output\":\"\"}]','{\"timeLimit\":1000,\"memoryLimit\":1000,\"stackLimit\":1000}',0,0,1860211680122777602,'2024-12-29 21:53:34','2024-12-29 21:53:34',0);
/*!40000 ALTER TABLE `question` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `question_set`
--

DROP TABLE IF EXISTS `question_set`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `question_set` (
                                `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
                                `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '题目集名称',
                                `description` text COLLATE utf8mb4_unicode_ci COMMENT '题目集描述',
                                `questionIds` text COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '题目 id 列表 (json 数组)',
                                `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
                                `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
                                `userId` bigint NOT NULL COMMENT '创建用户 id',
                                `isDelete` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除',
                                PRIMARY KEY (`id`),
                                KEY `idx_userId` (`userId`)
) ENGINE=InnoDB AUTO_INCREMENT=1873366940131598339 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='题目集';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `question_set`
--

LOCK TABLES `question_set` WRITE;
/*!40000 ALTER TABLE `question_set` DISABLE KEYS */;
INSERT INTO `question_set` VALUES (1845301324355227649,'预备备测试题','大家测试一下','[\"1844216221361299458\",\"1844652329786224641\",\"1845093212373405698\",\"1844652758788026369\",\"1845094162697834497\",\"1845094662285578242\",\"1845118475895328770\",\"1845118184223428610\"]','2024-10-13 11:11:34','2024-10-13 11:11:34',1844659788059840513,0),(1845310054601973762,'pta第一次测试','新生专属','[\"1845118562763558914\",\"1845118475895328770\",\"1845094662285578242\",\"1845094883665137666\",\"1845093820048363522\",\"1845093578993324033\"]','2024-10-13 11:46:16','2024-10-13 11:46:16',1844659788059840513,0),(1845355502603673602,'能AC的人才做的题','来吧，AC的大佬们！！！','[\"1844216221361299458\",\"1844652329786224641\",\"1845093820048363522\",\"1845094162697834497\",\"1845118184223428610\",\"1845094883665137666\",\"1845118562763558914\",\"1845118475895328770\"]','2024-10-13 14:46:52','2024-10-13 14:46:52',1844659788059840513,0),(1845423839031382017,'热热热融入','哈哈哈哈','[\"1844216221361299458\",\"1845093578993324033\",\"1844652329786224641\",\"1845093820048363522\",\"1845094662285578242\",\"1845118184223428610\",\"1845093212373405698\",\"1845094452876562433\",\"1845118562763558914\"]','2024-10-13 19:18:24','2024-10-13 19:18:24',1844659788059840513,0),(1853670556411387905,'升级版算法集','这个算法集非常牛掰','[\"1844216221361299458\",\"1845093578993324033\",\"1844652329786224641\",\"1845093820048363522\",\"1844652758788026369\"]','2024-11-05 13:27:55','2024-11-05 13:27:55',1844659788059840514,0),(1853670788838744066,'算法入门01','算法入门题目','[\"1844216221361299458\",\"1845093578993324033\",\"1845094662285578242\",\"1845118475895328770\"]','2024-11-05 13:28:50','2024-11-05 13:28:50',1844659788059840514,0),(1853670819058704385,'算法入门02','算法入门题目2','[\"1844216221361299458\",\"1845093578993324033\",\"1845094662285578242\",\"1845118475895328770\",\"1844652758788026369\"]','2024-11-05 13:28:57','2024-11-05 13:28:57',1844659788059840514,0),(1853671005390659586,'算法入门03','算法入门题目2','[\"1844216221361299458\",\"1845093578993324033\",\"1845094662285578242\",\"1845118475895328770\",\"1844652758788026369\",\"1844652329786224641\"]','2024-11-05 13:29:42','2024-11-05 13:29:42',1844659788059840514,0),(1853671021387735042,'算法入门04','算法入门题目2','[\"1844216221361299458\",\"1845093578993324033\",\"1845094662285578242\",\"1845118475895328770\",\"1844652758788026369\",\"1844652329786224641\"]','2024-11-05 13:29:46','2024-11-05 13:29:46',1844659788059840514,0),(1853671035342184449,'算法入门05','算法入门题目2','[\"1844216221361299458\",\"1845093578993324033\",\"1845094662285578242\",\"1845118475895328770\",\"1844652758788026369\",\"1844652329786224641\"]','2024-11-05 13:29:49','2024-11-05 13:29:49',1844659788059840514,0),(1853671048994643969,'算法入门06','算法入门题目2','[\"1844216221361299458\",\"1845093578993324033\",\"1845094662285578242\",\"1845118475895328770\",\"1844652758788026369\",\"1844652329786224641\"]','2024-11-05 13:29:52','2024-11-05 13:29:52',1844659788059840514,0),(1853671068963725313,'算法入门07','算法入门题目2','[\"1844216221361299458\",\"1845093578993324033\",\"1845094662285578242\",\"1845118475895328770\",\"1844652758788026369\",\"1844652329786224641\"]','2024-11-05 13:29:57','2024-11-05 13:29:57',1844659788059840514,0),(1853671233728569345,'算法入门06','算法入门','[\"1844216221361299458\",\"1844216221361299458\",\"1845093578993324033\",\"1844216221361299458\",\"1844652329786224641\",\"1845093820048363522\",\"1845094883665137666\"]','2024-11-05 13:30:36','2024-11-05 13:30:36',1844659788059840514,0),(1853671245405511681,'算法入门07','算法入门','[\"1844216221361299458\",\"1844216221361299458\",\"1845093578993324033\",\"1844216221361299458\",\"1844652329786224641\",\"1845093820048363522\",\"1845094883665137666\"]','2024-11-05 13:30:39','2024-11-05 13:30:39',1844659788059840514,0),(1853671254226132993,'算法入门08','算法入门','[\"1844216221361299458\",\"1844216221361299458\",\"1845093578993324033\",\"1844216221361299458\",\"1844652329786224641\",\"1845093820048363522\",\"1845094883665137666\"]','2024-11-05 13:30:41','2024-11-05 13:30:41',1844659788059840514,0),(1873366940131598338,'题目集合一套','题目集合','[\"1845093578993324033\",\"1845093578993324033\",\"1844216221361299458\",\"1845093578993324033\",\"1844652329786224641\",\"1845093820048363522\",\"1844652758788026369\",\"1845094162697834497\",\"1845093212373405698\",\"1845094452876562433\"]','2024-12-29 13:54:19','2024-12-29 13:54:19',1860211680122777602,0);
/*!40000 ALTER TABLE `question_set` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `question_submit`
--

DROP TABLE IF EXISTS `question_submit`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `question_submit` (
                                   `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
                                   `language` varchar(128) NOT NULL COMMENT '编程语言',
                                   `code` text NOT NULL COMMENT '用户代码',
                                   `judgeInfo` text COMMENT '判题信息（json 对象）',
                                   `status` int NOT NULL DEFAULT '0' COMMENT '判题状态（0 - 待判题、1 - 判题中、2 - 成功、3 - 失败）',
                                   `questionId` bigint NOT NULL COMMENT '题目 id',
                                   `userId` bigint NOT NULL COMMENT '创建用户 id',
                                   `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
                                   `updateTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
                                   `isDelete` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除',
                                   PRIMARY KEY (`id`),
                                   KEY `idx_questionId` (`questionId`),
                                   KEY `idx_userId` (`userId`)
) ENGINE=InnoDB AUTO_INCREMENT=1873364140643393539 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='题目提交';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `question_submit`
--

LOCK TABLES `question_submit` WRITE;
/*!40000 ALTER TABLE `question_submit` DISABLE KEYS */;
INSERT INTO `question_submit` VALUES (1844216442984128514,'java','import java.util.Scanner;\r\n\r\npublic class MaxSubarraySum {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 读取整数 K\r\n        int K = scanner.nextInt();\r\n        scanner.nextLine(); // 读取换行符\r\n\r\n        // 读取 K 个整数\r\n        String[] numbersStr = scanner.nextLine().split(\" \");\r\n        int[] numbers = new int[K];\r\n        for (int i = 0; i < K; i++) {\r\n            numbers[i] = Integer.parseInt(numbersStr[i]);\r\n        }\r\n\r\n        // 计算最大子列和\r\n        int maxSum = findMaxSubarraySum(numbers);\r\n\r\n        // 输出结果\r\n        System.out.println(maxSum);\r\n    }\r\n\r\n    /**\r\n     * 使用 Kadane 算法找到最大子列和\r\n     *\r\n     * @param nums 给定的整数序列\r\n     * @return 最大子列和\r\n     */\r\n    private static int findMaxSubarraySum(int[] nums) {\r\n        int maxSoFar = 0;\r\n        int maxEndingHere = 0;\r\n\r\n        for (int num : nums) {\r\n            maxEndingHere += num;\r\n            if (maxEndingHere < 0) {\r\n                maxEndingHere = 0;\r\n            }\r\n            if (maxEndingHere > maxSoFar) {\r\n                maxSoFar = maxEndingHere;\r\n            }\r\n        }\r\n\r\n        return maxSoFar;\r\n    }\r\n}\r\n','{}',1,1844216221361299458,1,'2024-10-10 11:20:38','2024-10-10 11:20:38',0),(1844242739303067649,'java','import java.util.Scanner;\r\n\r\npublic class MaxSubarraySum {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 读取整数 K\r\n        int K = scanner.nextInt();\r\n        scanner.nextLine(); // 读取换行符\r\n\r\n        // 读取 K 个整数\r\n        String[] numbersStr = scanner.nextLine().split(\" \");\r\n        int[] numbers = new int[K];\r\n        for (int i = 0; i < K; i++) {\r\n            numbers[i] = Integer.parseInt(numbersStr[i]);\r\n        }\r\n\r\n        // 计算最大子列和\r\n        int maxSum = findMaxSubarraySum(numbers);\r\n\r\n        // 输出结果\r\n        System.out.println(maxSum);\r\n    }\r\n\r\n    /**\r\n     * 使用 Kadane 算法找到最大子列和\r\n     *\r\n     * @param nums 给定的整数序列\r\n     * @return 最大子列和\r\n     */\r\n    private static int findMaxSubarraySum(int[] nums) {\r\n        int maxSoFar = 0;\r\n        int maxEndingHere = 0;\r\n\r\n        for (int num : nums) {\r\n            maxEndingHere += num;\r\n            if (maxEndingHere < 0) {\r\n                maxEndingHere = 0;\r\n            }\r\n            if (maxEndingHere > maxSoFar) {\r\n                maxSoFar = maxEndingHere;\r\n            }\r\n        }\r\n\r\n        return maxSoFar;\r\n    }\r\n}\r\n','{}',1,1844216221361299458,1,'2024-10-10 13:05:08','2024-10-10 13:05:08',0),(1844243443178582018,'java','import java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class JavaCodeSandboxTemplate {\r\n\r\n    public ExecuteMessage compileFile(File userCodeFile) {\r\n        // 检查文件是否存在并且是文件\r\n        if (!userCodeFile.exists()) {\r\n            throw new RuntimeException(\"文件不存在: \" + userCodeFile.getAbsolutePath());\r\n        }\r\n\r\n        if (!userCodeFile.isFile()) {\r\n            throw new RuntimeException(\"不是文件: \" + userCodeFile.getAbsolutePath());\r\n        }\r\n\r\n        String compileCmd = String.format(\"javac -encoding utf-8 %s\", userCodeFile.getAbsolutePath());\r\n        try {\r\n            Process compileProcess = Runtime.getRuntime().exec(compileCmd);\r\n            ExecuteMessage executeMessage = ProcessUtils.runProcessAndGetMessage(compileProcess, \"编译\");\r\n\r\n            if (executeMessage.getExitValue() != 0) {\r\n                // 获取编译错误信息\r\n                String errorMessage = executeMessage.getErrorMessage();\r\n                throw new RuntimeException(\"编译错误: \" + errorMessage);\r\n            }\r\n\r\n            return executeMessage;\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}\r\n','{}',1,1844216221361299458,1,'2024-10-10 13:07:55','2024-10-10 13:07:55',0),(1844243786822103041,'java','import java.util.Scanner;\r\n\r\npublic class MaxSubarraySum {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 读取整数 K\r\n        int K = scanner.nextInt();\r\n        scanner.nextLine(); // 读取换行符\r\n\r\n        // 读取 K 个整数\r\n        String[] numbersStr = scanner.nextLine().split(\" \");\r\n        int[] numbers = new int[K];\r\n        for (int i = 0; i < K; i++) {\r\n            numbers[i] = Integer.parseInt(numbersStr[i]);\r\n        }\r\n\r\n        // 计算最大子列和\r\n        int maxSum = findMaxSubarraySum(numbers);\r\n\r\n        // 输出结果\r\n        System.out.println(maxSum);\r\n    }\r\n\r\n    /**\r\n     * 使用 Kadane 算法找到最大子列和\r\n     *\r\n     * @param nums 给定的整数序列\r\n     * @return 最大子列和\r\n     */\r\n    private static int findMaxSubarraySum(int[] nums) {\r\n        int maxSoFar = 0;\r\n        int maxEndingHere = 0;\r\n\r\n        for (int num : nums) {\r\n            maxEndingHere += num;\r\n            if (maxEndingHere < 0) {\r\n                maxEndingHere = 0;\r\n            }\r\n            if (maxEndingHere > maxSoFar) {\r\n                maxSoFar = maxEndingHere;\r\n            }\r\n        }\r\n\r\n        return maxSoFar;\r\n    }\r\n}\r\n','{}',1,1844216221361299458,1,'2024-10-10 13:09:17','2024-10-10 13:09:17',0),(1844244825637920770,'java','import java.util.Scanner;\r\n\r\npublic class MaxSubarraySum {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 读取整数 K\r\n        int K = scanner.nextInt();\r\n        scanner.nextLine(); // 读取换行符\r\n\r\n        // 读取 K 个整数\r\n        String[] numbersStr = scanner.nextLine().split(\" \");\r\n        int[] numbers = new int[K];\r\n        for (int i = 0; i < K; i++) {\r\n            numbers[i] = Integer.parseInt(numbersStr[i]);\r\n        }\r\n\r\n        // 计算最大子列和\r\n        int maxSum = findMaxSubarraySum(numbers);\r\n\r\n        // 输出结果\r\n        System.out.println(maxSum);\r\n    }\r\n\r\n    /**\r\n     * 使用 Kadane 算法找到最大子列和\r\n     *\r\n     * @param nums 给定的整数序列\r\n     * @return 最大子列和\r\n     */\r\n    private static int findMaxSubarraySum(int[] nums) {\r\n        int maxSoFar = 0;\r\n        int maxEndingHere = 0;\r\n\r\n        for (int num : nums) {\r\n            maxEndingHere += num;\r\n            if (maxEndingHere < 0) {\r\n                maxEndingHere = 0;\r\n            }\r\n            if (maxEndingHere > maxSoFar) {\r\n                maxSoFar = maxEndingHere;\r\n            }\r\n        }\r\n\r\n        return maxSoFar;\r\n    }\r\n}\r\n','{}',1,1844216221361299458,1,'2024-10-10 13:13:25','2024-10-10 13:13:25',0),(1845375114720436226,'java','wasdawawd','{}',1,1844216221361299458,1844659788059840513,'2024-10-13 16:04:47','2024-10-13 16:04:47',0),(1845375438017388545,'java','import java.util.Scanner;\r\n\r\npublic class Main {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        // 读取整数 K\r\n        int K = scanner.nextInt();\r\n        scanner.nextLine(); // 读取换行符\r\n\r\n        // 读取 K 个整数\r\n        String[] numbersStr = scanner.nextLine().split(\" \");\r\n        int[] numbers = new int[K];\r\n        for (int i = 0; i < K; i++) {\r\n            numbers[i] = Integer.parseInt(numbersStr[i]);\r\n        }\r\n\r\n        // 计算最大子列和\r\n        int maxSum = findMaxSubarraySum(numbers);\r\n\r\n        // 输出结果\r\n        System.out.println(maxSum);\r\n\r\n        scanner.close();\r\n    }\r\n\r\n    /**\r\n     * 使用 Kadane 算法找到最大子列和\r\n     *\r\n     * @param nums 整数数组\r\n     * @return 最大子列和\r\n     */\r\n    public static int findMaxSubarraySum(int[] nums) {\r\n        int maxSoFar = 0;\r\n        int maxEndingHere = 0;\r\n\r\n        for (int num : nums) {\r\n            maxEndingHere += num;\r\n            if (maxEndingHere < 0) {\r\n                maxEndingHere = 0;\r\n            }\r\n            if (maxSoFar < maxEndingHere) {\r\n                maxSoFar = maxEndingHere;\r\n            }\r\n        }\r\n\r\n        return maxSoFar;\r\n    }\r\n}\r\n','{\"message\":\"Wrong Answer\",\"memory\":0,\"time\":5016}',2,1844216221361299458,1844659788059840513,'2024-10-13 16:06:04','2024-10-13 16:06:10',0),(1845376028734775298,'java','import java.util.Scanner;\r\n\r\npublic class Main {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        while (scanner.hasNext()) {\r\n            double c = scanner.nextDouble();\r\n\r\n            if (c == 0.00) {\r\n                break;\r\n            }\r\n\r\n            int cardsNeeded = calculateCardsNeeded(c);\r\n            System.out.printf(\"%d card(s)\\n\", cardsNeeded);\r\n        }\r\n\r\n        scanner.close();\r\n    }\r\n\r\n    /**\r\n     * 计算实现至少 c 卡长度悬空所需的最小卡片数量\r\n     *\r\n     * @param c 目标悬空长度\r\n     * @return 最小卡片数量\r\n     */\r\n    public static int calculateCardsNeeded(double c) {\r\n        double harmonicSum = 0.0;\r\n        int n = 0;\r\n\r\n        while (harmonicSum < c) {\r\n            n++;\r\n            harmonicSum += 1.0 / n;\r\n        }\r\n\r\n        return n;\r\n    }\r\n}\r\n','{\"message\":\"Accepted\",\"memory\":0,\"time\":5014}',2,1845093212373405698,1844659788059840513,'2024-10-13 16:08:25','2024-10-13 16:08:31',0),(1845376403177070594,'java','import java.util.Scanner;\r\n\r\npublic class Main {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n\r\n        int testCases = scanner.nextInt();\r\n\r\n        for (int i = 0; i < testCases; i++) {\r\n            int columns = scanner.nextInt();\r\n            int[] heights = new int[columns];\r\n\r\n            for (int j = 0; j < columns; j++) {\r\n                heights[j] = scanner.nextInt();\r\n            }\r\n\r\n            int operations = calculateOperations(heights);\r\n            System.out.println(operations);\r\n        }\r\n\r\n        scanner.close();\r\n    }\r\n\r\n    /**\r\n     * 计算使用翻倍消除器的有效操作次数\r\n     *\r\n     * @param heights 各列的高度\r\n     * @return 有效操作次数\r\n     */\r\n    public static int calculateOperations(int[] heights) {\r\n        int operations = 0;\r\n        int k = 0;\r\n\r\n        while (true) {\r\n            boolean used = false;\r\n            int nextK = k + 1;\r\n            int power = 1 << k;\r\n\r\n            for (int i = 0; i < heights.length; i++) {\r\n                if (heights[i] >= power) {\r\n                    heights[i] -= power;\r\n                    used = true;\r\n                }\r\n            }\r\n\r\n            if (!used) {\r\n                break;\r\n            }\r\n\r\n            if (used) {\r\n                operations++;\r\n            }\r\n\r\n            k = nextK;\r\n        }\r\n\r\n        return operations;\r\n    }\r\n}\r\n','{\"message\":\"Wrong Answer\",\"memory\":0,\"time\":5048}',2,1844652329786224641,1844659788059840513,'2024-10-13 16:09:54','2024-10-13 16:10:00',0),(1845423557841047553,'java','public','{}',1,1844216221361299458,1844659788059840513,'2024-10-13 19:17:17','2024-10-13 19:17:17',0),(1852254223262035969,'java','','{}',1,1844216221361299458,1844659788059840513,'2024-11-01 15:39:54','2024-11-01 15:39:54',0),(1873359720627118081,'java','public main','{}',1,1844216221361299458,1860211680122777602,'2024-12-29 21:25:37','2024-12-29 21:25:37',0),(1873364140643393538,'java','public class main{\r\n    public static void main(String[] args){\r\n        \r\n    }\r\n}','{}',1,1845094883665137666,1860211680122777602,'2024-12-29 21:43:11','2024-12-29 21:43:11',0);
/*!40000 ALTER TABLE `question_submit` ENABLE KEYS */;
UNLOCK TABLES;
